/*global define,console,document*/
/*jslint nomen: true*/
/**
 * Based on F# computation expressions http://msdn.microsoft.com/en-us/library/dd233182.aspx
 **/
define([
    'scalejs!core'
], function (
    core
) {
    'use strict';

    var //merge = core.object.merge,
        //clone = core.object.clone,
        array = core.array;


    function builder(opts) {
        var build,
            self;

        function callExpr(expr) {
            if (!expr || expr.kind !== '$') {
                return typeof expr === 'function' ? expr.bind(self) : expr;
            }

            if (typeof expr.expr === 'function') {
                return expr.expr.call(self);
            }

            if (typeof expr.expr === 'string') {
                return self[expr.expr];
            }

            throw new Error('Parameter in $(...) must be either a function or a string referencing a binding.');
        }

        function combine(method, expr, cexpr) {
            function isReturnLikeMethod(method) {
                return method === '$return' ||
                        method === '$RETURN' ||
                        method === '$yield' ||
                        method === '$YIELD';
            }

            if (typeof self[method] !== 'function' &&
                    method !== '$then' &&
                    method !== '$else') {
                throw new Error('This control construct may only be used if the computation expression builder ' +
                                'defines a `' + method + '` method.');
            }

            var e = callExpr(expr),
                //contextCopy,
                cexprCopy;

            if (cexpr.length > 0 && typeof self.combine !== 'function') {
                throw new Error('This control construct may only be used if the computation expression builder ' +
                                'defines a `combine` method.');
            }

            // if it's return then simply return
            if (isReturnLikeMethod(method)) {
                if (cexpr.length === 0) {
                    return self[method](e);
                }

                if (typeof self.delay !== 'function') {
                    throw new Error('This control construct may only be used if the computation expression builder ' +
                                    'defines a `delay` method.');
                }

                // combine with delay
                return self.combine(self[method](e), self.delay(function () {
                    return build(cexpr);
                }));
            }

            // if it's not a return then simply combine the operations (e.g. no `delay` needed)
            if (method === '$for') {
                return self.combine(self.$for(expr.items, function (item) {
                    var cexpr = array.copy(expr.cexpr);
                    //ctx = merge(context);
                    self[expr.name] = item;
                    return build(cexpr);
                }), build(cexpr));
            }

            if (method === '$while') {
                if (typeof self.delay !== 'function') {
                    throw new Error('This control construct may only be used if the computation expression builder ' +
                                    'defines a `delay` method.');
                }

                e = self.$while(expr.condition.bind(self), self.delay(function () {
                    var //contextCopy = clone(context),
                        cexprCopy = array.copy(expr.cexpr);
                    return build(cexprCopy);
                }));

                if (cexpr.length > 0) {
                    return self.combine(e, build(cexpr));
                }

                return e;
            }

            if (method === '$then' || method === '$else') {
                //contextCopy = clone(context);
                cexprCopy = array.copy(expr.cexpr);
                return self.combine(build(cexprCopy), cexpr);
            }

            return self.combine(self[method](e), build(cexpr));
        }

        if (!opts.missing) {
            opts.missing = function (expr) {
                if (expr.kind) {
                    throw new Error('Unknown operation "' + expr.kind + '". ' +
                                    'Either define `missing` method on the builder or fix the spelling of the operation.');
                }

                throw new Error('Expression ' + JSON.stringify(expr) + ' cannot be processed. ' +
                                'Either define `missing` method on the builder or convert expression to a function.');
            };
        }

        build = function (cexpr) {
            var expr;

            cexpr = array.copy(cexpr);

            if (cexpr.length === 0) {
                if (self.zero) {
                    return self.zero();
                }

                throw new Error('Computation expression builder must define `zero` method.');
            }

            expr = cexpr.shift();

            if (expr.kind === 'let') {
                self[expr.name] = callExpr(expr.expr);
                return build(cexpr);
            }

            if (expr.kind === 'do') {
                expr.expr.call(self);
                return build(cexpr);
            }

            if (expr.kind === 'letBind') {
                return self.bind(expr.expr, function (bound) {
                    self[expr.name] = bound;
                    return build(cexpr);
                });
            }

            if (expr.kind === 'doBind' || expr.kind === '$') {
                if (cexpr.length > 0) {
                    return self.bind(expr.expr, function () {
                        return build(cexpr);
                    });
                }

                if (typeof self.$return !== 'function') {
                    throw new Error('This control construct may only be used if the computation expression builder ' +
                                    'defines a `$return` method.');
                }

                return self.bind(expr.expr, function () {
                    return self.$return();
                });
            }

            if (expr.kind === '$return' ||
                    expr.kind === '$RETURN' ||
                    expr.kind === '$yield' ||
                    expr.kind === '$YIELD') {
                return combine(expr.kind, expr.expr, cexpr);
            }

            if (expr.kind === '$for' ||
                    expr.kind === '$while') {
                return combine(expr.kind, expr, cexpr);
            }

            if (expr.kind === '$if') {
                if (expr.condition.call(self)) {
                    return combine('$then', expr.thenExpr, cexpr);
                }

                if (expr.elseExpr) {
                    return combine('$else', expr.elseExpr, cexpr);
                }

                return combine(build([]), cexpr);
            }

            if (typeof expr === 'function' && self.call) {
                self.call(expr);
                return build(cexpr);
            }

            if (typeof expr === 'function') {
                expr.call(self);
                return build(cexpr);
            }

            return combine('missing', expr, cexpr);
        };

        return function () {
            var args = array.copy(arguments),
                expression = function () {
                    var operations = Array.prototype.slice.call(arguments, 0),
                        result,
                        delayed,
                        //run,
                        built;


                    // Copy all opts to `self`. Nothing special (e.g. recursion, etc.) is required since opts
                    // must be a flat object with builder methods
                    self = {};
                    Object.keys(opts).forEach(function (key) {
                        self[key] = opts[key];
                    });

                    if (this.mixins) {
                        this.mixins.forEach(function (mixin) {
                            if (mixin.beforeBuild) {
                                mixin.beforeBuild(operations);
                            }
                        });
                    }

                    built = function () {
                        return build(operations);
                    };

                    if (!self.run && !self.delay) {
                        result = built();
                    } else {
                        if (self.delay) {
                            delayed = built;
                            built = function () {
                                return self.delay(delayed);
                            };
                        }

                        result = built();

                        if (self.run) {
                            result = self.run.apply(self, [result].concat(args));
                        }
                    }

                    if (this.mixins) {
                        this.mixins.forEach(function (mixin) {
                            if (mixin.afterBuild) {
                                result = mixin.afterBuild(result);
                            }
                        });
                    }

                    return result;
                };

            function mixin() {
                var context = { mixins: Array.prototype.slice.call(arguments, 0) },
                    bound = expression.bind(context);
                bound.mixin = function () {
                    Array.prototype.push.apply(context.mixins, arguments);
                    return bound;
                };

                return bound;
            }

            expression.mixin = mixin;

            return expression;
        };
    }

    builder.$let = function (name, expr) {
        return {
            kind: 'let',
            name: name,
            expr: expr
        };
    };

    builder.$LET = function (name, expr) {
        return {
            kind: 'letBind',
            name: name,
            expr: expr
        };
    };

    builder.$do = function (expr) {
        return {
            kind: 'do',
            expr: expr
        };
    };

    builder.$DO = function (expr) {
        return {
            kind: 'doBind',
            expr: expr
        };
    };

    builder.$return = function (expr) {
        return {
            kind: '$return',
            expr: expr
        };
    };

    builder.$RETURN = function (expr) {
        return {
            kind: '$RETURN',
            expr: expr
        };
    };

    builder.$yield = function (expr) {
        return {
            kind: '$yield',
            expr: expr
        };
    };

    builder.$YIELD = function (expr) {
        return {
            kind: '$YIELD',
            expr: expr
        };
    };

    builder.$for = function (name, items) {
        var cexpr = Array.prototype.slice.call(arguments, 2);

        return {
            kind: '$for',
            name: name,
            items: items,
            cexpr: cexpr
        };
    };

    builder.$while = function (condition) {
        if (arguments.length < 2) {
            throw new Error('Incomplete `while`. Expected "$while(<condition>, <expr>)".');
        }

        var cexpr = Array.prototype.slice.call(arguments, 1);

        return {
            kind: '$while',
            condition: condition,
            cexpr: cexpr
        };
    };

    builder.$if = function (condition, thenExpr, elseExpr) {
        if (arguments.length < 2) {
            throw new Error('Incomplete conditional. Expected "$if(<expr>, $then(expr))" or ' +
                            '"$if(<expr>, $then(<expr>), $else(<expr>)"');
        }

        if (typeof condition !== 'function') {
            throw new Error('First argument must be a function that defines the condition of $if.');
        }

        if (thenExpr.kind !== '$then') {
            throw new Error('Unexpected "' + thenExpr.kind + '" in the place of "$then"');
        }

        if (elseExpr) {
            if (elseExpr.kind !== '$else') {
                throw new Error('Unexpected "' + elseExpr.kind + '" in the place of "$else"');
            }
        }

        return {
            kind: '$if',
            condition: condition,
            thenExpr: thenExpr,
            elseExpr: elseExpr
        };
    };

    builder.$then = function () {
        var cexpr = Array.prototype.slice.call(arguments, 0);

        if (cexpr.length === 0) {
            throw new Error('$then should contain at least one expression.');
        }

        return {
            kind: '$then',
            cexpr: cexpr
        };
    };

    builder.$else = function () {
        var cexpr = Array.prototype.slice.call(arguments, 0);

        if (cexpr.length === 0) {
            throw new Error('$else should contain at least one expression.');
        }

        return {
            kind: '$else',
            cexpr: cexpr
        };
    };

    builder.$ = function (expr) {
        return {
            kind: '$',
            expr: expr
        };
    };

    return builder;
});
